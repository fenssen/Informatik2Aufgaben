import java.util.ArrayList;/** * Die Klasse Dictionary implementiert den ADT Dictionary durch * einen Binaerbaum, dessen Knoten vom Typ BSTNode<E> sind. * Der Binaerbaum wird mit Hilfe eines Platzhalters (sentinel) * implementiert. Dieser Platzhalter wird selbst durch einen * BSTNode dargestellt, speichert aber kein Datenobjekt dauerhaft. * Fuer alle Baumknoten, die keinen linken oder rechten Teilbaum  * haben, verweist der entsprechende Zeiger nicht auf null, sondern * auf den sentinel Knoten.  * @version 1.0 * @author Marcel Schoppmeier */public class Dictionary<E extends Comparable<E>> {    //Attribute    /**     * Zeiger auf den Platzhalterknoten, dessen left Zeiger auf den     * Wurzelknoten des Baumes verweist.     */    public BSTNode<E> dict = null;    private int processcount = 0;    //Listen in denen gespeichert wird bei welchem Schritt eine Rotation durchgefuehrt wird    ArrayList<Integer> linksrotation = new ArrayList<>();    ArrayList<Integer> rechtsrotation = new ArrayList<>();    ArrayList<Integer> doppellinksrotation = new ArrayList<>();    ArrayList<Integer> doppelrechtsrotation = new ArrayList<>();    // Konstruktoren    /**     * Der Konstruktor erzeugt ein neues Dictionary.     */    public Dictionary()  {        dict = new BSTNode<E>();        dict.setLeftNode(dict);        dict.setRightNode(dict);    }        //Dienste    /**     * Ermittelt Hoehe des Baumes     * @param k Knoten, ab dem die Hoehe ermittelt werden soll	 * @return Hoehe     */    public int height(BSTNode<E> k){        if (k.getData() == dict.getData())//sentinel        {            return 0;         }        return 1+(int) Math.max(height(k.getLeftNode()),height(k.getRightNode()));    }    /**     * strukturiert Baum neu     * @param k aktueller Knoten     * @param k_old Vaterknoten     */    public void restructure(BSTNode<E> k, BSTNode<E> k_old){        if(k.getData() == dict.getData())//Abbruchbedingung        {            return;        }        this.refreshBalance(dict.getLeftNode());//von Wurzelknoten aus        //eventuell Rotieren um die AVL-Bedingung wiederherzustellen:        if (Math.abs(k.getBalance())>=2)        {            rotate(k, k_old); //abs ist Betrag        }        restructure(k.getRightNode(), k);        restructure(k.getLeftNode(), k);            }    /**     * Balancewerte aller Knoten werden aktualisiert     * @param k Knoten, ab dem aktualisiert wird     */    public void refreshBalance(BSTNode<E> k)//Methode funktioniert    {        if(k.getData() == dict.getData())        {            return;        }        //Balancewerte anpassen        k.setBalance(height(k.getRightNode())- height(k.getLeftNode()));        refreshBalance(k.getRightNode());        refreshBalance(k.getLeftNode());    }    /**     * guckt, welche Rotation ausgefuehrt werden muss     * @param k aktueller Knoten     * @param k_old Vaterknoten     */    public void rotate(BSTNode<E> k, BSTNode<E> k_old){        if ((k.getBalance()==2)&&(k.getRightNode().getBalance()==1))    {            Linksrotation(k,k_old);            linksrotation.add(processcount);            return;        }        if ((k.getBalance()==-2)&&(k.getLeftNode().getBalance()==-1))          {            Rechtsrotation(k,k_old);            rechtsrotation.add(processcount);            return;        }        if ((k.getBalance()==2)&&(k.getRightNode().getBalance()==-1))           {            DoppelLinksrotation(k,k_old);            doppellinksrotation.add(processcount);            return;        }        if ((k.getBalance()==-2)&&(k.getLeftNode().getBalance()==1))          {            DoppelRechtsrotation(k,k_old);            doppelrechtsrotation.add(processcount);            return;        }    }    /**     * fuehrt Doppellinksrotation aus vergleiche Vorlesung     * @param a aktueller Knoten     * @param a_father Vaterknoten     */    public void DoppelLinksrotation(BSTNode<E> a, BSTNode<E> a_father)    {        if(a_father.getRightNode().getData() == a.getData())//es wird auf b verwiesen, wobei ueberprueft werden muss an welches Kind des Vaterknoten b dran muss        {            a_father.setRightNode(a.getRightNode().getLeftNode());        }        else        {            a_father.setLeftNode(a.getRightNode().getLeftNode());        }        BSTNode<E> x = a.getRightNode().getLeftNode().getLeftNode(); //linker Kindknoten von b        BSTNode<E> y = a.getRightNode().getLeftNode().getRightNode();        a.getRightNode().getLeftNode().setRightNode(a.getRightNode()); // b bekommt rechten Kinderknoten c        a.getRightNode().getLeftNode().setLeftNode(a); //b bekommt linken Kinderknoten a        a.getRightNode().setLeftNode(y);        a.setRightNode(x);    }    /**     * fuehrt Doppelrechtsrotation aus vergleiche Vorlesung     * @param a aktueller Knoten     * @param a_father Vaterknoten     */    public void DoppelRechtsrotation(BSTNode<E> a, BSTNode<E> a_father)    {        if(a_father.getRightNode().getData() == a.getData())//es wird auf b verwiesen, wobei ueberprueft werden muss an welches Kind des Vaterknoten b dran muss        {            a_father.setRightNode(a.getLeftNode().getRightNode());        }        else        {            a_father.setLeftNode(a.getLeftNode().getRightNode());        }        BSTNode<E> x = a.getLeftNode().getRightNode().getRightNode(); //rechter Kinderknoten von b        BSTNode<E> y = a.getLeftNode().getRightNode().getLeftNode();//linker Kinderknoten von b        a.getLeftNode().getRightNode().setLeftNode(a.getLeftNode()); // b bekommt linken Kinderknoten c        a.getLeftNode().getRightNode().setRightNode(a); //b bekommt rechten Kinderknoten a        a.getLeftNode().setRightNode(y);        a.setLeftNode(x);    }    /**     * fuehrt Linksrotation aus vergleiche Vorlesung     * @param a aktueller Knoten     * @param a_father Vaterknoten     */    public void Linksrotation(BSTNode<E> a, BSTNode<E> a_father)    {        if(a_father.getRightNode().getData() == a.getData())//es wird auf b verwiesen, wobei ueberprueft werden muss an welches Kind des Vaterknoten b dran muss        {            a_father.setRightNode(a.getRightNode());        }        else        {            a_father.setLeftNode(a.getRightNode());        }        BSTNode<E> tmp = a.getRightNode().getLeftNode(); //von b der linke Teilbaum y        a.getRightNode().setLeftNode(a); //b bekommt a als linken Nachfloger        a.setRightNode(tmp);//a bekommt y teilbaum als rechten Nachfolger    }    /**     * fuehrt Rechtsrotation aus vergleiche Vorlesung     * @param a aktueller Knoten     * @param a_father Vaterknoten     */    public void Rechtsrotation(BSTNode<E> a, BSTNode<E> a_father)    {        if(a_father.getRightNode().getData() == a.getData())//es wird auf b verwiesen, wobei ueberprueft werden muss an welches Kind des Vaterknoten b dran muss        {            a_father.setRightNode(a.getLeftNode());//Vaterknoten bekommt b als Nachfolger        }        else        {            a_father.setLeftNode(a.getLeftNode());//Vaterknoten bekommt b als Nachfolger        }        BSTNode<E> tmp = a.getLeftNode().getRightNode(); //von b der rechten Teilbaum y        a.getLeftNode().setRightNode(a); //b bekommt a als rechten Nachfloger        a.setLeftNode(tmp);//a bekommt y teilbaum als linken Nachfolger    }    /**     * Fuegt das Element x in das Dictionary ein. Ist x bereits     * im Dictionary vorhanden, so passiert nichts.     * @param E Einzufuegendes Element      */    public void insert(E x) {        dict.setData(x); // initialisiere Element in Platzhalter        BSTNode<E> p = dict.getLeftNode(); // Zeiger auf gegenwaertigen Knoten        BSTNode<E> o = dict; // Zeiger auf Vorgaenger        int compValue = x.compareTo(p.getData());        while (compValue != 0) { // solange x nicht gefunden            o = p; // aktualisiere Vorgaenger            if (compValue < 0) // suche links weiter                p = p.getLeftNode();            else // suche rechts weiter                p = p.getRightNode();            compValue = x.compareTo(p.getData());        }        if (p == dict) { // x ist noch nicht im Baum            p = new BSTNode<E>(x,dict, dict);            if (x.compareTo(o.getData()) > 0) // rechter Nachfolger von o            {                o.setRightNode(p);            }            else // linker Nachfolger von o            {                o.setLeftNode(p);            }        }        dict.setData(null);        processcount++;        this.restructure(dict.getLeftNode(),dict);//Wurzelknoten und sentinel    }    /**     * Entfernt das Element x aus dem Dictionary. Ist x     * nicht im Dictionary enthalten, so passiert nichts.     * @param Comparable Zu entfernendes Element      */    public void delete(E x)//loeschen wie im Binaerbaum    {        dict.setData(x); // initialisiere Element in Platzhalter        BSTNode<E> p = dict.getLeftNode(); // Zeiger auf gegenwaertigen Knoten        BSTNode<E> o = dict; // Zeiger auf Vorg�nger        int compValue = x.compareTo(p.getData());        while (compValue != 0) { // solange x nicht gefunden            o = p; // aktualisiere Vorg�nger            if (compValue < 0) // suche links weiter                p = p.getLeftNode();            else // suche rechts weiter                p = p.getRightNode();            compValue = x.compareTo(p.getData());        }        if (p != dict) { // x wurde gefunden            if ((p.getLeftNode() != dict) && (p.getRightNode() != dict)) {                // p hat linkes und rechtes Kind                // suche groesstes Element im linken Teilbaum                BSTNode<E> t = p.getLeftNode(); // Zeiger auf gegenwaertigen Knoten                BSTNode<E> s = p; // Zeiger auf Vorgaenger                while (t.getRightNode() != dict) {                    // solange groesseres Element existiert                    s = t; // aktualisiere Vorg�nger                    t = t.getRightNode(); // gehe rechts                }                if (t.getData().compareTo(s.getData()) < 0)                    s.setLeftNode(t.getLeftNode());                else                    s.setRightNode(t.getLeftNode());                p.setData(t.getData());            } else { // p hat hoechstens ein Kind                if (p.getLeftNode() != dict) // p hat linkes Kind                    p = p.getLeftNode();                else if (p.getRightNode() != dict) // p hat rechtes Kind                    p = p.getRightNode();                else // p hat keine Kinder                    p = dict;                if (x.compareTo(o.getData()) > 0)                    o.setRightNode(p);                else                    o.setLeftNode(p);            }        }        dict.setData(null);        processcount++;        this.restructure(dict.getLeftNode(),dict);//Wurzelknoten und sentinel    }    /**     * Liefert "true" zurueck, falls das Dictionary     * leer ist, sonst "false".      */    public boolean isempty() {        return (dict.getLeftNode() == dict);    }    /**     * leitete Traversierung ein     */    public void traverse() {        System.out.print("Traversierung: ");        traverse(dict.getLeftNode());//wegen dem sentinel        System.out.println();    }    /**     * traversiert ab Knoten t     * @param t Knoten, ab dem traversiert wird     */    public void traverse(BSTNode<E> t) {        if (t != dict) {            System.out.print("(" + t.getData().toString());            traverse(t.getLeftNode());            traverse(t.getRightNode());            System.out.print(")");        }    }    /**     * Gibt true zurueck, falls das Element x im Dictionary     * enthalten ist, sonst false.     * @param E Abzufragendes Element      */    public boolean isMember(E x) {        dict.setData(x); // initialisiere Element in Platzhalter        BSTNode<E> t = dict.getLeftNode(); // initialisiere Zeiger auf Wurzel        int compValue = x.compareTo(t.getData());        while (compValue != 0) { // solange x nicht gefunden            if (compValue < 0) // suche links weiter                t = t.getLeftNode();            else // suche rechts weiter                t = t.getRightNode();            compValue = x.compareTo(t.getData());        }        dict.setData(null);//sentinell auf Null setzen        return (t != dict);//wenn while vorher unterbrochen wird, weiss man, dass x enthalten i    }} // class Dictionary 